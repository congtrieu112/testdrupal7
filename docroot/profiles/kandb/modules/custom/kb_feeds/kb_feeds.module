<?php

/**
 * Search by term name.
 */
define('KB_FEEDS_TAXONOMY_SEARCH_TERM_NAME', 0);

/**
 * Search by term id.
 */
define('KB_FEEDS_TAXONOMY_SEARCH_TERM_ID', 1);

/**
 * Search by GUID.
 */
define('KB_FEEDS_TAXONOMY_SEARCH_TERM_GUID', 2);

/**
 * Search by field id file.
 */
define('KB_FEEDS_TAXONOMY_SEARCH_TERM_FIELD_ID_FILE', 3);

function kb_feeds_feeds_plugins() {
  $info = array();
  $path = drupal_get_path('module', 'kb_feeds');

  $info['KbFeedsProcessor'] = array(
    'hidden' => TRUE,
    'handler' => array(
      'parent' => 'FeedsPlugin',
      'class' => 'KbFeedsProcessor',
      'file' => 'KbFeedsProcessor.inc',
      'path' => $path,
    ),
  );

  $info['KbFeedsCSVParser'] = array(
    'name' => 'KB CSV parser',
    'description' => 'Parse data in Comma Separated Value format.',
    'handler' => array(
      'parent' => 'FeedsParser',
      'class' => 'KbFeedsCSVParser',
      'file' => 'KbFeedsCSVParser.inc',
      'path' => $path,
    ),
  );
  
  $info['KbEncodingCSVParser'] = array(
    'name' => 'KB migration program video parser',
    'description' => 'Only use for "Migration program video import" importer.',
    'handler' => array(
      'parent' => 'FeedsParser',
      'class' => 'KbEncodingCSVParser',
      'file' => 'KbEncodingCSVParser.inc',
      'path' => $path,
    ),
  );

  $info['KbFeedsNodeProcessor'] = array(
    'name' => 'KB Node processor',
    'description' => 'Create and update nodes.',
    'help' => 'Create and update nodes from parsed content.',
    'handler' => array(
      'parent' => 'FeedsProcessor',
      'class' => 'KbFeedsNodeProcessor',
      'file' => 'KbFeedsNodeProcessor.inc',
      'path' => $path,
    ),
  );
  $info['KbFeedsMiNodeProcessor'] = array(
    'name' => 'KB multiple importer node processor',
    'description' => 'Create and update nodes by 2 feeds importer.',
    'help' => 'Create and update nodes from parsed content by 2 feeds importer.',
    'handler' => array(
      'parent' => 'FeedsProcessor',
      'class' => 'KbFeedsMiNodeProcessor',
      'file' => 'KbFeedsMiNodeProcessor.inc',
      'path' => $path,
    ),
  );
  $info['KbFeedsHTTPFetcher'] = array(
    'name' => 'KB HTTP fetcher',
    'description' => 'Download content from a URL.',
    'help' => 'Download content from a URL.',
    'handler' => array(
      'parent' => 'FeedsFetcher',
      'class' => 'KbFeedsHTTPFetcher',
      'file' => 'KbFeedsHTTPFetcher.inc',
      'path' => $path,
    ),
  );


  return $info;
}

/**
 * Implements hook_feeds_processor_targets_alter()
 * @param array $targets
 * @param type $entity_type
 * @param type $bundle
 */
function kb_feeds_feeds_processor_targets_alter(array &$targets, $entity_type, $bundle) {
  if ($entity_type == 'node' && $bundle == 'bien') {
    if (isset($targets['field_bien_statut'])) {
      $targets['field_bien_statut']['callback'] = 'field_bien_statut_feeds_set_target';
      $targets['field_bien_statut']['summary_callbacks'][0] = 'field_bien_statut_feeds_summary_callback';
      $targets['field_bien_statut']['form_callbacks'][0] = 'field_bien_statut_feeds_form_callback';
    }
  }
}

function field_bien_statut_feeds_form_callback(array $mapping, $target, array $form, array $form_state) {
  return array(
    'term_search' => array(
      '#type' => 'select',
      '#title' => t('Search taxonomy terms by'),
      '#options' => array(
        KB_FEEDS_TAXONOMY_SEARCH_TERM_NAME => 'Term name',
        KB_FEEDS_TAXONOMY_SEARCH_TERM_ID => 'Term ID',
        KB_FEEDS_TAXONOMY_SEARCH_TERM_GUID => 'GUID',
        KB_FEEDS_TAXONOMY_SEARCH_TERM_FIELD_ID_FILE => 'Field id file'
      ),
      '#default_value' => !empty($mapping['term_search']) ? $mapping['term_search'] : KB_FEEDS_TAXONOMY_SEARCH_TERM_NAME,
    ),
    'autocreate' => array(
      '#type' => 'checkbox',
      '#title' => t('Auto create'),
      '#description' => t("Create the term if it doesn't exist."),
      '#default_value' => !empty($mapping['autocreate']) ? $mapping['autocreate'] : 0,
      '#states' => array(
        'visible' => array(
          ':input[name$="[settings][term_search]"]' => array('value' => KB_FEEDS_TAXONOMY_SEARCH_TERM_NAME),
        ),
      ),
    ),
  );
}

function field_bien_statut_feeds_set_target(FeedsSource $source, $entity, $target, array $terms, array $mapping) {
  // Add in default values.
  $mapping += array(
    'term_search' => KB_FEEDS_TAXONOMY_SEARCH_TERM_NAME,
    'autocreate' => FALSE,
  );

  $info = field_info_field($target);

  $cache = &drupal_static(__FUNCTION__);
  if (!isset($cache['allowed_values'][$target])) {
    $cache['allowed_values'][$target] = taxonomy_allowed_values($info);
  }

  if (!isset($cache['allowed_vocabularies'][$target])) {
    foreach ($info['settings']['allowed_values'] as $tree) {
      if ($vocabulary = taxonomy_vocabulary_machine_name_load($tree['vocabulary'])) {
        $cache['allowed_vocabularies'][$target][$vocabulary->vid] = $vocabulary->machine_name;
      }
    }
  }

  // Some kind of configuration issue. Perhaps the vocabulary was deleted.
  // Nothing we can do about it.
  if (empty($cache['allowed_vocabularies'][$target])) {
    return;
  }

  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'taxonomy_term')
    ->entityCondition('bundle', $cache['allowed_vocabularies'][$target])
    ->range(0, 1);


  $field = isset($entity->$target) ? $entity->$target : array('und' => array());

  // Allow for multiple mappings to the same target.
  $delta = count($field['und']);

  // Iterate over all values.
  foreach ($terms as $term) {

    if ($info['cardinality'] == $delta) {
      break;
    }

    $tid = FALSE;

    // FeedsTermElement already is a term.
    if ($term instanceof FeedsTermElement) {
      $tid = $term->tid;
    } else {
      switch ($mapping['term_search']) {

        // Lookup by name.
        case KB_FEEDS_TAXONOMY_SEARCH_TERM_NAME:
          $term = trim($term);
          $name_query = clone $query;
          if (strlen($term) && $tids = $name_query->propertyCondition('name', $term)->execute()) {

            // Find the first allowed term.
            foreach ($tids['taxonomy_term'] as $possible_term) {
              if (isset($cache['allowed_values'][$target][$possible_term->tid])) {
                $tid = $possible_term->tid;
                break;
              }
            }
          } elseif ($mapping['autocreate'] && strlen($term)) {
            $term = (object) array(
                'name' => drupal_substr($term, 0, 255),
                'vid' => key($cache['allowed_vocabularies'][$target]),
                'vocabulary_machine_name' => reset($cache['allowed_vocabularies'][$target]),
            );
            taxonomy_term_save($term);
            $tid = $term->tid;
            // Add to the list of allowed values.
            $cache['allowed_values'][$target][$tid] = $term->name;
          }
          break;

        // Lookup by tid.
        case KB_FEEDS_TAXONOMY_SEARCH_TERM_ID:
          if (is_numeric($term)) {
            $tid = (int) $term;
          }
          break;

        case KB_FEEDS_TAXONOMY_SEARCH_TERM_FIELD_ID_FILE:
          $query = new EntityFieldQuery();
          $query->entityCondition('entity_type', 'taxonomy_term')
            ->entityCondition('bundle', $cache['allowed_vocabularies'][$target])
            ->fieldCondition('field_id_file', 'value', $term, '=')
            ->range(0, 1);
          $results = $query->execute();
          foreach ($results["taxonomy_term"] as $result) {
            $tid = $result->tid;
          }
          break;

        // Lookup by GUID.
        case KB_FEEDS_TAXONOMY_SEARCH_TERM_GUID:
          $tid = kb_feeds_taxonomy_feeds_term_lookup_term_by_guid($term);
          break;
      }
    }

    if ($tid && isset($cache['allowed_values'][$target][$tid])) {
      $field['und'][] = array('tid' => $tid);
      $delta++;
    }
  }

  $entity->$target = $field;
}

/**
 * Looks up a term by GUID, assumes SQL storage backend.
 *
 * @param string $guid
 *   The Feeds GUID to compare against.
 *
 * @return int|FALSE
 *   The term id, or FALSE if one was not found.
 */
function kb_feeds_taxonomy_feeds_term_lookup_term_by_guid($guid) {
  return db_select('feeds_item')
      ->fields('feeds_item', array('entity_id'))
      ->condition('entity_type', 'taxonomy_term')
      ->condition('guid', $guid)
      ->execute()
      ->fetchField();
}

/**
 * Mapping configuration summary for taxonomy.module.
 */
function field_bien_statut_feeds_summary_callback(array $mapping, $target, array $form, array $form_state) {
  $options = array(
    KB_FEEDS_TAXONOMY_SEARCH_TERM_NAME => 'Term name',
    KB_FEEDS_TAXONOMY_SEARCH_TERM_ID => 'Term ID',
    KB_FEEDS_TAXONOMY_SEARCH_TERM_GUID => 'GUID',
    KB_FEEDS_TAXONOMY_SEARCH_TERM_FIELD_ID_FILE => 'Field id file'
  );
  if (empty($mapping['term_search'])) {
    return t('Search taxonomy terms by: <strong>@search</strong>', array('@search' => $options[FEEDS_TAXONOMY_SEARCH_TERM_NAME]));
  }
  return t('Search taxonomy terms by: <strong>@search</strong>', array('@search' => $options[$mapping['term_search']]));
}

function getListTidTaxonomyByName($bundle, $value) {
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'taxonomy_term')
    ->entityCondition('bundle', $bundle)
    ->range(0, 1);
  $name_query = clone $query;
  $tids = $name_query->propertyCondition('name', $value)->execute();

  foreach ($tids["taxonomy_term"] as $possible_term) {
    $tid = $possible_term->tid;
  }

  return $tid;
}
	 
/**	 
 * Implements hook_feeds_presave	 
 * @param FeedsSource $source 
 * @param type $entity
 * @param type $item
 */	 
function kb_feeds_feeds_presave(FeedsSource $source, $entity, $item) {	 
  $tid = 0;	 
  if ($entity->feeds_item->entity_type == 'node') {	 
    if ($entity->feeds_item->id == 'programme_feed_import') {	 
      if ($entity->field_tva_55[LANGUAGE_NONE][0]['value']) { 
        $terms = taxonomy_get_term_by_name('TVA 5.5%', 'tva');	 
        if ($terms) {	 
          foreach ($terms as $key => $value) {	 
            $tid = $key; 
          }	 
        }	 
      } 
    } elseif ($entity->feeds_item->id == 'parcel_feed_import') {	 
      if (isset($entity->field_programme[LANGUAGE_NONE][0]['target_id'])) { 
        $nodes = node_load($entity->field_programme[LANGUAGE_NONE][0]['target_id']);
        if($nodes) {	 
          $tid = $nodes->field_tva[LANGUAGE_NONE][0]['tid'];	 
        }	 
      }	 
    }	 
  }	 

  if ($tid > 0) {	 
    $entity->field_tva[LANGUAGE_NONE][0]['tid'] = $tid;	 
  }	 
}